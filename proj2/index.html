<html>
	<head>
	</head>
	<body>
		<h2>
		Project 2
		</h2>
		<h3>
			Link: https://cal-cs184-student.github.io/sp22-project-webpages-laursl/proj2/index.html
		</h3>
		<h3>
			Overview
		</h3>
		<p> With this project I was able to explore geometric modeling. I feel like I have a stronger grasp of exactly how edge flipping and edge splitting work now.
		</p>
		<h3>
			Task 1
		</h3>
		<p> De Casteljau's algorithm computes points on a Bezier curve. We were given the info that we can use linear interpolation to compute the n-1 intermediate control points at the parameter t in the next subdivision level, with the new pi = (1 - t)p_i + t * p_(i+1). 

		</p>
		<h4>
			Stepping through the de Casteljau's with a Bezier curve with 6 control points.
		</h4>
		<img src="task1_1.png" alt="task1 photo">
		<img src="task1_2.png" alt="task1 photo">
		<img src="task1_3.png" alt="task1 photo">
		<img src="task1_4.png" alt="task1 photo">
		<img src="task1_5.png" alt="task1 photo">
		<img src="task1_6.png" alt="task1 photo">
		<h4>
			A different curve
		</h4>
		<img src="task1_7.png" alt="task1 photo">
		<h3>
			Task 2
		</h3>
		<p> De Casteljau's algorithm extends to Bezier surfaces, which have 3D coordinates as we can perform vector math. The function BezierPatch::evaluateStep() was exactly the same as the BezierCurve::evaluateStep(). In evaluate1D(), I called evaluateStep() until there was only one point left in the vector. To evaluate a Bezier surface, I evalutated each row of the controlPoints with u as the scalar interpolation parameter, then evaluated the resulting 1D vector with v as the scalar interpolation parameter to get the final point.
		</p>

		<h4>
			Teapot
		</h4>
		<img src="task2.png" alt="task2 photo">
		<h3>
			Task 3
		</h3>
		<p> 
			I implemented area-weighted vertex normals by terating through all the neighboring faces of the vertex and summing up their normals. I then normalized the sum.
		</p>
		<h4>
			Shading with vertex normals
		</h4>
		<img src="task3_1.png" alt="task3 photo">
		<h4>
			Shading without vertex normals
		</h4>
		<img src="task3_1.png" alt="task3 photo">
		<h3>
			Task 4
		</h3>
		<p> 
			I implemented the edge flip by listing out all the elements involved, then using this photo to reassign pointers. 
		</p>
		<h4>
			Diagram of edge flip
		</h4>
		<img src="task4_1.png" alt="task4 photo">
		<h4>
			After some edge flips on the teapot
		</h4>
		<img src="task4.png" alt="task4 photo">
		<h3>
			Task 5
		</h3>
		<p> 
			I implemented the edge flip by listing out all the elements involved. I then created all the new elements needed, like the new vertex, 3 new edges, and 2 new faces. I then used this diagram that I drew to reassign everything. I had to go over the assignments a couple times to fix some bugs. Later I also assigned the isNew member of the new edges created in this function so upsampling would work properly.
		</p>
		<h4>
			Diagram of edge split
		</h4>
		<img src="task5_1.png" alt="task5 photo">
		<h4>
			After some edge splits on the teapot
		</h4>
		<img src="task5_2.png" alt="task5 photo">
		<h4>
			After some edge splits and flips on the teapot
		</h4>
		<img src="task5_3.png" alt="task5 photo">
		<h3>
			Task 6
		</h3>
		<p> 
			I implemented loop subdivision by following the commented steps in the starter code. This means I first computed new positions for every existing vertex and also new positions for the soon-to-be-created vertices. I saved the existing vertices' newPositions in their newPosition member and saved the new vertices' positions in the existing edges' newPositions member. Then I split every existing edge in the mesh using mesh.splitEdge(). Then I flipped new edges which were connected to a existing vertex and a new vertex using mesh.flipEdge(). Finally I copied the new positions I computed in the beginning into all the vertices.

			At first I had a lot of trouble with new positions being set to (0, 0, 0). I fixed this by making sure that I was finding the right edge to assign the new position of a new vertex. I also made a mistake where I was iterating over vertices one time without realizing that one vertice connects to several edges. I fixed this by iterating over edges instead.

			I also made sure that I set all the existing vertices/edges isNew member to false in the beginning of the function.

			Meshes seem to get smoother after loop subdivision. Sharp corners and edges are reduced and kind of fall into the mesh but leave tight areas of small triangles.
		<h4>
			Iterations of loop subdivision on the cube
		</h4>
		<img src="task6_1.png" alt="task6 photo">
		<img src="task6_2.png" alt="task6 photo">
		<img src="task6_3.png" alt="task6 photo">
		<img src="task6_4.png" alt="task6 photo">
		<h4>
			Iterations of loop subdivision on the cube after splitting the edge going diagonally on each face.
		</h4>
		<img src="task6_5.png" alt="task6 photo">
		<img src="task6_7.png" alt="task6 photo">
		<img src="task6_8.png" alt="task6 photo">
		<img src="task6_9.png" alt="task6 photo">
		</p>
	</body>
</html>